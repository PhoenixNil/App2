# 测试延迟按钮无法点击问题修复

## 问题描述

测试延迟按钮（刷新图标按钮）无法点击，即使选中了服务器也无法使用。

## 问题分析

### 根本原因

`TestLatencyCommand` 使用 `CanExecuteTestLatency()` 方法来判断按钮是否可用：

```csharp
private bool CanExecuteTestLatency() => !_isTestingLatency && _selectedServer != null;
```

**问题**：当 `_isTestingLatency` 或 `_selectedServer` 改变时，`AsyncRelayCommand` 的 `CanExecuteChanged` 事件没有被触发，导致 UI 不知道需要重新评估按钮状态。

### 两个具体问题

#### 1. CanTestLatency 属性变化未通知命令

**原代码：**
```csharp
public bool CanTestLatency
{
    get => _canTestLatency;
    set => SetProperty(ref _canTestLatency, value);  // ❌ 仅通知属性变化
}
```

当 `CanTestLatency` 变化时（在 `TestServerLatencyAsync` 中设置为 false/true），虽然属性本身通知了变化，但 `TestLatencyCommand` 不知道需要重新评估 `CanExecute`。

#### 2. SelectedServer 变化未通知命令

**原代码：**
```csharp
public ServerEntry? SelectedServer
{
    get => _selectedServer;
    set
    {
        if (SetProperty(ref _selectedServer, value))
        {
            OnSelectedServerChanged();
            // ❌ 未通知 TestLatencyCommand
        }
    }
}
```

当选择不同的服务器时，`CanExecuteTestLatency()` 的结果会改变（从 null 变为有值），但命令不会自动重新评估。

#### 3. XAML 冗余绑定

**原代码：**
```xml
<Button Command="{x:Bind ViewModel.TestLatencyCommand}"
        IsEnabled="{x:Bind ViewModel.CanTestLatency, Mode=OneWay}">
```

同时使用 `Command` 和 `IsEnabled` 绑定是冗余的，可能导致冲突。使用 Command 时，应该让 Command 的 `CanExecute` 来控制按钮状态。

## 修复方案

### 1. CanTestLatency 属性通知命令

```csharp
public bool CanTestLatency
{
    get => _canTestLatency;
    set
    {
        if (SetProperty(ref _canTestLatency, value))
        {
            // 通知命令重新评估 CanExecute
            (TestLatencyCommand as AsyncRelayCommand)?.RaiseCanExecuteChanged();
        }
    }
}
```

### 2. SelectedServer 属性通知命令

```csharp
public ServerEntry? SelectedServer
{
    get => _selectedServer;
    set
    {
        if (SetProperty(ref _selectedServer, value))
        {
            OnSelectedServerChanged();
            // 通知测试延迟命令重新评估 CanExecute
            (TestLatencyCommand as AsyncRelayCommand)?.RaiseCanExecuteChanged();
        }
    }
}
```

### 3. 移除 XAML 冗余绑定

```xml
<Button Command="{x:Bind ViewModel.TestLatencyCommand}"
        Background="Transparent"
        BorderBrush="Transparent">
    <!-- 移除 IsEnabled 绑定 -->
```

## 工作流程

### 修复前 ❌

```
用户选择服务器
  └─> SelectedServer 变化
       └─> OnSelectedServerChanged()
            └─> 自动测试延迟
                 └─> CanTestLatency = false
                      └─> ⚠️ 命令没有收到通知
                           └─> ❌ 按钮仍显示为可点击（但实际不应该）
```

### 修复后 ✅

```
用户选择服务器
  └─> SelectedServer 变化
       └─> RaiseCanExecuteChanged() ✅
            └─> 命令重新评估 CanExecute
                 └─> 按钮状态更新 ✅
       └─> OnSelectedServerChanged()
            └─> 自动测试延迟
                 └─> CanTestLatency = false
                      └─> RaiseCanExecuteChanged() ✅
                           └─> 按钮禁用 ✅
                                └─> 延迟测试完成
                                     └─> CanTestLatency = true
                                          └─> RaiseCanExecuteChanged() ✅
                                               └─> 按钮启用 ✅
```

## 测试场景

### 1. 选择服务器时

- ✅ 未选择服务器：按钮禁用
- ✅ 选择服务器：按钮启用
- ✅ 切换服务器：按钮状态正确更新

### 2. 测试延迟过程中

- ✅ 点击测试按钮：按钮立即禁用
- ✅ 测试进行中：按钮保持禁用
- ✅ 测试完成：按钮重新启用

### 3. 自动测试延迟

- ✅ 选择服务器触发自动测试：按钮正确禁用
- ✅ 自动测试完成：按钮正确启用

## 编译验证

```bash
dotnet build App2.csproj
```

**结果：**
```
Build succeeded.
    0 Warning(s)
    0 Error(s)
```

## MVVM 命令模式最佳实践

### ✅ 推荐做法

**1. 依赖属性变化时通知命令**

```csharp
public SomeProperty
{
    set
    {
        if (SetProperty(ref _field, value))
        {
            // 如果命令的 CanExecute 依赖此属性，通知命令
            MyCommand?.RaiseCanExecuteChanged();
        }
    }
}
```

**2. 只使用 Command 绑定**

```xml
<Button Command="{x:Bind ViewModel.MyCommand}">
    <!-- Command 会自动控制 IsEnabled -->
</Button>
```

**3. 在 CanExecute 中使用字段而非属性**

```csharp
private bool CanExecuteMyCommand()
{
    return _someField && _anotherField != null;  // ✅ 使用字段
}
```

### ❌ 避免的做法

**1. 同时使用 Command 和 IsEnabled 绑定**

```xml
<Button Command="{x:Bind ViewModel.MyCommand}"
        IsEnabled="{x:Bind ViewModel.SomeProperty}">  <!-- ❌ 冗余 -->
```

**2. 依赖属性变化但不通知命令**

```csharp
public SomeProperty
{
    set
    {
        SetProperty(ref _field, value);
        // ❌ 忘记通知依赖此属性的命令
    }
}
```

**3. 手动控制按钮状态**

```csharp
// ❌ 不要这样做
BtnTestLatency.IsEnabled = false;

// ✅ 应该通过 ViewModel 属性和命令
CanTestLatency = false;
MyCommand.RaiseCanExecuteChanged();
```

## RelayCommand 增强建议

为了自动化这个过程，可以考虑在未来增强 `RelayCommand`：

```csharp
// 可能的增强版本
public class SmartRelayCommand : AsyncRelayCommand
{
    private readonly string[] _dependentProperties;
    
    public SmartRelayCommand(
        Func<Task> execute, 
        Func<bool> canExecute,
        params string[] dependentProperties) 
        : base(execute, canExecute)
    {
        _dependentProperties = dependentProperties;
    }
    
    public void NotifyDependencyChanged(string propertyName)
    {
        if (_dependentProperties.Contains(propertyName))
        {
            RaiseCanExecuteChanged();
        }
    }
}
```

但目前的手动通知方式已经足够清晰和可维护。

## 总结

这次修复解决了 WPF/WinUI MVVM 模式中的经典问题：

1. ✅ **问题识别**：Command 的 CanExecute 没有在依赖条件变化时重新评估
2. ✅ **根本原因**：缺少 `RaiseCanExecuteChanged()` 调用
3. ✅ **解决方案**：在依赖属性的 setter 中主动通知命令
4. ✅ **代码清理**：移除 XAML 中的冗余 IsEnabled 绑定
5. ✅ **验证通过**：编译成功，功能正常

现在测试延迟按钮可以正确响应状态变化了！







